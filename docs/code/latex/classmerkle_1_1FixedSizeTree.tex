\hypertarget{classmerkle_1_1FixedSizeTree}{}\doxysection{merkle\+::Fixed\+Size\+Tree$<$ Hasher, LEAFS\+\_\+N, Hash, Concatenator $>$ Class Template Reference}
\label{classmerkle_1_1FixedSizeTree}\index{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$@{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$}}


General class of Merkle trees calculated at the compilation stage and trees with a size calculated at the compilation stage.  




{\ttfamily \#include $<$merkle.\+hpp$>$}



Inheritance diagram for merkle\+::Fixed\+Size\+Tree$<$ Hasher, LEAFS\+\_\+N, Hash, Concatenator $>$\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classmerkle_1_1FixedSizeTree__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for merkle\+::Fixed\+Size\+Tree$<$ Hasher, LEAFS\+\_\+N, Hash, Concatenator $>$\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classmerkle_1_1FixedSizeTree__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T $>$ }\\constexpr \mbox{\hyperlink{classmerkle_1_1FixedSizeTree_ad2924778107ad8109ea5020fae91b567}{Fixed\+Size\+Tree}} (Hasher \+\_\+h, Concatenator \+\_\+c, T \&\&\+\_\+data)
\begin{DoxyCompactList}\small\item\em constructor for immediate creation of a tree from a data container \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classmerkle_1_1FixedSizeTree_ae2e94c283d763017573663ec4873fd6c}\label{classmerkle_1_1FixedSizeTree_ae2e94c283d763017573663ec4873fd6c}} 
{\footnotesize template$<$typename T $>$ }\\constexpr {\bfseries Fixed\+Size\+Tree} (T \&\&\+\_\+data)
\item 
\mbox{\Hypertarget{classmerkle_1_1FixedSizeTree_ac83dd70c7cffcfc5bae7fb6b717395f8}\label{classmerkle_1_1FixedSizeTree_ac83dd70c7cffcfc5bae7fb6b717395f8}} 
constexpr {\bfseries Fixed\+Size\+Tree} (Hasher \+\_\+h, Concatenator \+\_\+c)
\item 
constexpr auto \mbox{\hyperlink{classmerkle_1_1FixedSizeTree_a5881fef0fe6cef5db23f4376deaab672}{build}} (auto \&\&ccont)
\begin{DoxyCompactList}\small\item\em build a tree based on a data container \end{DoxyCompactList}\item 
constexpr auto \mbox{\hyperlink{classmerkle_1_1FixedSizeTree_a1e83ceba6bae13a495051128cc7c57db}{get\+\_\+proof}} (auto \&\&\mbox{\hyperlink{classmerkle_1_1FixedSizeTree_a9944fdfb42d2dbf306d9593dbeda0b24}{data}}) const
\begin{DoxyCompactList}\small\item\em creates a proof of inclusion of some data in the tree \end{DoxyCompactList}\item 
constexpr auto \mbox{\hyperlink{classmerkle_1_1FixedSizeTree_a4a036578d0c54e5ce948fe1ff621f8bc}{verify\+\_\+proof}} (auto \&\&\mbox{\hyperlink{classmerkle_1_1FixedSizeTree_a9944fdfb42d2dbf306d9593dbeda0b24}{data}}, auto \&\&proof)
\item 
constexpr auto \mbox{\hyperlink{classmerkle_1_1FixedSizeTree_a4f71698ce937b5fc840dcd66a5c046b6}{root}} () const
\begin{DoxyCompactList}\small\item\em root of the Merkle tree \end{DoxyCompactList}\item 
constexpr auto \mbox{\hyperlink{classmerkle_1_1FixedSizeTree_a9944fdfb42d2dbf306d9593dbeda0b24}{data}} () const
\begin{DoxyCompactList}\small\item\em returns a pointer (or iterator) to the hash tree \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static constexpr auto \mbox{\hyperlink{classmerkle_1_1FixedSizeTree_af6d478cdee1df86043d0dfcb416a8f50}{get\+\_\+leafs\+\_\+n}} ()
\begin{DoxyCompactList}\small\item\em current num of leaves in the tree \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
constexpr auto \mbox{\hyperlink{classmerkle_1_1FixedSizeTree_aa6c502a770736034677d4a289a291329}{get\+\_\+layer}} (const size\+\_\+t idx) const
\begin{DoxyCompactList}\small\item\em finds a pointer to a tree layer by index and its size \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classmerkle_1_1FixedSizeTree_aaeeabf627a4786c9afc254dae2e3551c}\label{classmerkle_1_1FixedSizeTree_aaeeabf627a4786c9afc254dae2e3551c}} 
std\+::ostream \& {\bfseries operator$<$$<$} (std\+::ostream \&os, \mbox{\hyperlink{classmerkle_1_1FixedSizeTree}{Fixed\+Size\+Tree}}$<$ Hasher, LEAFS\+\_\+N, Hash, Concatenator $>$ \&tree)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename Hasher, uint64\+\_\+t LEAFS\+\_\+N, typename Hash = Hasher\+::value\+\_\+type, typename Concatenator = bconcat\+::\+Unified\+Concatenator$>$\newline
class merkle\+::\+Fixed\+Size\+Tree$<$ Hasher, LEAFS\+\_\+\+N, Hash, Concatenator $>$}

General class of Merkle trees calculated at the compilation stage and trees with a size calculated at the compilation stage. 

built on the basis of std\+::array to ensure maximum performance. The elements of each layer are laid out in a continuous section of memory, starting with N leaves, then N / 2 nodes, etc. Due to this stacking, an implicit concatenation of neighboring hashes occurs, and when calculating a node of the next level, exactly 0 operations are spent on adding its child elements. By default, preference is given to the construction algorithm with copying the last node on layers with an odd size, since the construction algorithm is much simpler for it, and the additional memory consumption is insignificant. 
\begin{DoxyTemplParams}{Template Parameters}
{\em Hasher} & type of hash function \\
\hline
{\em LEAFS\+\_\+N} & the number of leaves in the tree calculated at the compilation stage \\
\hline
\end{DoxyTemplParams}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classmerkle_1_1FixedSizeTree_ad2924778107ad8109ea5020fae91b567}\label{classmerkle_1_1FixedSizeTree_ad2924778107ad8109ea5020fae91b567}} 
\index{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$@{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$}!FixedSizeTree@{FixedSizeTree}}
\index{FixedSizeTree@{FixedSizeTree}!merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$@{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$}}
\doxysubsubsection{\texorpdfstring{FixedSizeTree()}{FixedSizeTree()}}
{\footnotesize\ttfamily template$<$typename Hasher , uint64\+\_\+t LEAFS\+\_\+N, typename Hash  = Hasher\+::value\+\_\+type, typename Concatenator  = bconcat\+::\+Unified\+Concatenator$>$ \\
template$<$typename T $>$ \\
constexpr \mbox{\hyperlink{classmerkle_1_1FixedSizeTree}{merkle\+::\+Fixed\+Size\+Tree}}$<$ Hasher, LEAFS\+\_\+N, Hash, Concatenator $>$\+::\mbox{\hyperlink{classmerkle_1_1FixedSizeTree}{Fixed\+Size\+Tree}} (\begin{DoxyParamCaption}\item[{Hasher}]{\+\_\+h,  }\item[{Concatenator}]{\+\_\+c,  }\item[{T \&\&}]{\+\_\+data }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}}



constructor for immediate creation of a tree from a data container 


\begin{DoxyParams}{Parameters}
{\em \+\_\+hash} & link to the hash function that will be used to build the tree \\
\hline
{\em \+\_\+data} & data container \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
the num of elements in the container should be equal to LEAFS\+\_\+N or LEAFS\+\_\+\+N-\/1 
\end{DoxyNote}
\begin{DoxyWarning}{Warning}
you can use containers with fewer than LEAFS\+\_\+N elements, but in this case some methods will give the wrong answer. Using a container with a size larger than LEAFS\+\_\+N leads to the building of a tree based only on the first LEAFS\+\_\+N elements. 
\end{DoxyWarning}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classmerkle_1_1FixedSizeTree_a5881fef0fe6cef5db23f4376deaab672}\label{classmerkle_1_1FixedSizeTree_a5881fef0fe6cef5db23f4376deaab672}} 
\index{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$@{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$}!build@{build}}
\index{build@{build}!merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$@{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$}}
\doxysubsubsection{\texorpdfstring{build()}{build()}}
{\footnotesize\ttfamily template$<$typename Hasher , uint64\+\_\+t LEAFS\+\_\+N, typename Hash  = Hasher\+::value\+\_\+type, typename Concatenator  = bconcat\+::\+Unified\+Concatenator$>$ \\
constexpr auto \mbox{\hyperlink{classmerkle_1_1FixedSizeTree}{merkle\+::\+Fixed\+Size\+Tree}}$<$ Hasher, LEAFS\+\_\+N, Hash, Concatenator $>$\+::build (\begin{DoxyParamCaption}\item[{auto \&\&}]{ccont }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}}



build a tree based on a data container 


\begin{DoxyParams}{Parameters}
{\em ccont} & data container \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
this object 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
O(\+N) complexity where N is equal to the number of hashes in the tree 
\end{DoxyNote}
\mbox{\Hypertarget{classmerkle_1_1FixedSizeTree_a9944fdfb42d2dbf306d9593dbeda0b24}\label{classmerkle_1_1FixedSizeTree_a9944fdfb42d2dbf306d9593dbeda0b24}} 
\index{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$@{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$}!data@{data}}
\index{data@{data}!merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$@{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$}}
\doxysubsubsection{\texorpdfstring{data()}{data()}}
{\footnotesize\ttfamily template$<$typename Hasher , uint64\+\_\+t LEAFS\+\_\+N, typename Hash  = Hasher\+::value\+\_\+type, typename Concatenator  = bconcat\+::\+Unified\+Concatenator$>$ \\
constexpr auto \mbox{\hyperlink{classmerkle_1_1FixedSizeTree}{merkle\+::\+Fixed\+Size\+Tree}}$<$ Hasher, LEAFS\+\_\+N, Hash, Concatenator $>$\+::data (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}}



returns a pointer (or iterator) to the hash tree 

\begin{DoxyReturn}{Returns}
pointer to the beginning of the tree (the leftmost element of the lower layer). The pointer is traversed from left to right from bottom to top. total number of hashes available 
\end{DoxyReturn}
\mbox{\Hypertarget{classmerkle_1_1FixedSizeTree_aa6c502a770736034677d4a289a291329}\label{classmerkle_1_1FixedSizeTree_aa6c502a770736034677d4a289a291329}} 
\index{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$@{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$}!get\_layer@{get\_layer}}
\index{get\_layer@{get\_layer}!merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$@{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$}}
\doxysubsubsection{\texorpdfstring{get\_layer()}{get\_layer()}}
{\footnotesize\ttfamily template$<$typename Hasher , uint64\+\_\+t LEAFS\+\_\+N, typename Hash  = Hasher\+::value\+\_\+type, typename Concatenator  = bconcat\+::\+Unified\+Concatenator$>$ \\
constexpr auto \mbox{\hyperlink{classmerkle_1_1FixedSizeTree}{merkle\+::\+Fixed\+Size\+Tree}}$<$ Hasher, LEAFS\+\_\+N, Hash, Concatenator $>$\+::get\+\_\+layer (\begin{DoxyParamCaption}\item[{const size\+\_\+t}]{idx }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [protected]}}



finds a pointer to a tree layer by index and its size 


\begin{DoxyParams}{Parameters}
{\em idx} & layer index (0 for the root, 1..N for the following) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to the beginning of the layer and its length (num of hashes) 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
index of the last layer is equal to the height value O(log\+N) complexity where N is equal to the number of hashes in the tree 
\end{DoxyNote}
\mbox{\Hypertarget{classmerkle_1_1FixedSizeTree_af6d478cdee1df86043d0dfcb416a8f50}\label{classmerkle_1_1FixedSizeTree_af6d478cdee1df86043d0dfcb416a8f50}} 
\index{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$@{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$}!get\_leafs\_n@{get\_leafs\_n}}
\index{get\_leafs\_n@{get\_leafs\_n}!merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$@{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$}}
\doxysubsubsection{\texorpdfstring{get\_leafs\_n()}{get\_leafs\_n()}}
{\footnotesize\ttfamily template$<$typename Hasher , uint64\+\_\+t LEAFS\+\_\+N, typename Hash  = Hasher\+::value\+\_\+type, typename Concatenator  = bconcat\+::\+Unified\+Concatenator$>$ \\
static constexpr auto \mbox{\hyperlink{classmerkle_1_1FixedSizeTree}{merkle\+::\+Fixed\+Size\+Tree}}$<$ Hasher, LEAFS\+\_\+N, Hash, Concatenator $>$\+::get\+\_\+leafs\+\_\+n (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [constexpr]}}



current num of leaves in the tree 

\begin{DoxyNote}{Note}
For fixed size class of trees, the function can be static, since it depends only on the class parameters, but not on a specific object 
\end{DoxyNote}
\mbox{\Hypertarget{classmerkle_1_1FixedSizeTree_a1e83ceba6bae13a495051128cc7c57db}\label{classmerkle_1_1FixedSizeTree_a1e83ceba6bae13a495051128cc7c57db}} 
\index{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$@{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$}!get\_proof@{get\_proof}}
\index{get\_proof@{get\_proof}!merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$@{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$}}
\doxysubsubsection{\texorpdfstring{get\_proof()}{get\_proof()}}
{\footnotesize\ttfamily template$<$typename Hasher , uint64\+\_\+t LEAFS\+\_\+N, typename Hash  = Hasher\+::value\+\_\+type, typename Concatenator  = bconcat\+::\+Unified\+Concatenator$>$ \\
constexpr auto \mbox{\hyperlink{classmerkle_1_1FixedSizeTree}{merkle\+::\+Fixed\+Size\+Tree}}$<$ Hasher, LEAFS\+\_\+N, Hash, Concatenator $>$\+::get\+\_\+proof (\begin{DoxyParamCaption}\item[{auto \&\&}]{data }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}}



creates a proof of inclusion of some data in the tree 


\begin{DoxyParams}{Parameters}
{\em data} & input for which the proof is being created \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pair from the hash of the leaf and an array of hashes from all levels, proving the inclusion of data in the tree 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
if the data was not used to build the tree, an object consisting of default values will be returned. For the data used in the construction, the first argument will always match the hash of the desired tree leaf. 

O(log\+N) complexity where N is equal to the number of hashes in the tree 
\end{DoxyNote}
\mbox{\Hypertarget{classmerkle_1_1FixedSizeTree_a4f71698ce937b5fc840dcd66a5c046b6}\label{classmerkle_1_1FixedSizeTree_a4f71698ce937b5fc840dcd66a5c046b6}} 
\index{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$@{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$}!root@{root}}
\index{root@{root}!merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$@{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$}}
\doxysubsubsection{\texorpdfstring{root()}{root()}}
{\footnotesize\ttfamily template$<$typename Hasher , uint64\+\_\+t LEAFS\+\_\+N, typename Hash  = Hasher\+::value\+\_\+type, typename Concatenator  = bconcat\+::\+Unified\+Concatenator$>$ \\
constexpr auto \mbox{\hyperlink{classmerkle_1_1FixedSizeTree}{merkle\+::\+Fixed\+Size\+Tree}}$<$ Hasher, LEAFS\+\_\+N, Hash, Concatenator $>$\+::root (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}}



root of the Merkle tree 

\begin{DoxyReturn}{Returns}
last (topmost) hash 
\end{DoxyReturn}
\mbox{\Hypertarget{classmerkle_1_1FixedSizeTree_a4a036578d0c54e5ce948fe1ff621f8bc}\label{classmerkle_1_1FixedSizeTree_a4a036578d0c54e5ce948fe1ff621f8bc}} 
\index{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$@{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$}!verify\_proof@{verify\_proof}}
\index{verify\_proof@{verify\_proof}!merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$@{merkle::FixedSizeTree$<$ Hasher, LEAFS\_N, Hash, Concatenator $>$}}
\doxysubsubsection{\texorpdfstring{verify\_proof()}{verify\_proof()}}
{\footnotesize\ttfamily template$<$typename Hasher , uint64\+\_\+t LEAFS\+\_\+N, typename Hash  = Hasher\+::value\+\_\+type, typename Concatenator  = bconcat\+::\+Unified\+Concatenator$>$ \\
constexpr auto \mbox{\hyperlink{classmerkle_1_1FixedSizeTree}{merkle\+::\+Fixed\+Size\+Tree}}$<$ Hasher, LEAFS\+\_\+N, Hash, Concatenator $>$\+::verify\+\_\+proof (\begin{DoxyParamCaption}\item[{auto \&\&}]{data,  }\item[{auto \&\&}]{proof }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}}

... \begin{DoxyNote}{Note}
O(log\+N) complexity where N is equal to the number of hashes in the tree 
\end{DoxyNote}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{merkle_8hpp}{merkle.\+hpp}}\end{DoxyCompactItemize}
