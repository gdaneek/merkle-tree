<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Merkle Tree: merkle::TreeBase&lt; Derived, HashFunc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Merkle Tree
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>merkle</b></li><li class="navelem"><a class="el" href="classmerkle_1_1TreeBase.html">TreeBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classmerkle_1_1TreeBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">merkle::TreeBase&lt; Derived, HashFunc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>a base template class for building Merkle trees based on CRTP  
 <a href="classmerkle_1_1TreeBase.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="merkle_8hpp_source.html">merkle.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac6b5c1e3375233161d4e19654e6b5c4c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmerkle_1_1TreeBase.html#ac6b5c1e3375233161d4e19654e6b5c4c">hash</a> (ContiguousContainer auto &amp;&amp;ccont) const</td></tr>
<tr class="memdesc:ac6b5c1e3375233161d4e19654e6b5c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash function wrapper that allows you to call it for any continuous container  <a href="classmerkle_1_1TreeBase.html#ac6b5c1e3375233161d4e19654e6b5c4c">More...</a><br /></td></tr>
<tr class="separator:ac6b5c1e3375233161d4e19654e6b5c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3dcd283a84eb8bb98021331b0120203"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmerkle_1_1TreeBase.html#af3dcd283a84eb8bb98021331b0120203">height</a> () const</td></tr>
<tr class="memdesc:af3dcd283a84eb8bb98021331b0120203"><td class="mdescLeft">&#160;</td><td class="mdescRight">function that calculates the height of a current Merkle tree  <a href="classmerkle_1_1TreeBase.html#af3dcd283a84eb8bb98021331b0120203">More...</a><br /></td></tr>
<tr class="separator:af3dcd283a84eb8bb98021331b0120203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35655e38316e0d8c9a25ff6e2116c53"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmerkle_1_1TreeBase.html#ad35655e38316e0d8c9a25ff6e2116c53">size</a> () const</td></tr>
<tr class="memdesc:ad35655e38316e0d8c9a25ff6e2116c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">function that calculates the number of elements (hashes) for a current Merkle tree  <a href="classmerkle_1_1TreeBase.html#ad35655e38316e0d8c9a25ff6e2116c53">More...</a><br /></td></tr>
<tr class="separator:ad35655e38316e0d8c9a25ff6e2116c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848a40df2b9f0a4c914b3cea86cd7734"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmerkle_1_1TreeBase.html#a848a40df2b9f0a4c914b3cea86cd7734">leaf_hash</a> (auto &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a848a40df2b9f0a4c914b3cea86cd7734"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the hash of a tree leaf  <a href="classmerkle_1_1TreeBase.html#a848a40df2b9f0a4c914b3cea86cd7734">More...</a><br /></td></tr>
<tr class="separator:a848a40df2b9f0a4c914b3cea86cd7734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46ad7d436941315d6b9a831f6b18f30"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmerkle_1_1TreeBase.html#ae46ad7d436941315d6b9a831f6b18f30">node_hash</a> (auto &amp;&amp;... args) const</td></tr>
<tr class="memdesc:ae46ad7d436941315d6b9a831f6b18f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the hash of a tree node  <a href="classmerkle_1_1TreeBase.html#ae46ad7d436941315d6b9a831f6b18f30">More...</a><br /></td></tr>
<tr class="separator:ae46ad7d436941315d6b9a831f6b18f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d5593ad35b425b3693af6fd2eac63c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmerkle_1_1TreeBase.html#a48d5593ad35b425b3693af6fd2eac63c">verify</a> (auto &amp;&amp;data) const</td></tr>
<tr class="memdesc:a48d5593ad35b425b3693af6fd2eac63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks whether the data block was used when creating the Merkle tree  <a href="classmerkle_1_1TreeBase.html#a48d5593ad35b425b3693af6fd2eac63c">More...</a><br /></td></tr>
<tr class="separator:a48d5593ad35b425b3693af6fd2eac63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0b01bb14099f6606b164b025611496"><td class="memItemLeft" align="right" valign="top"><a id="a2a0b01bb14099f6606b164b025611496"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmerkle_1_1TreeBase.html#a2a0b01bb14099f6606b164b025611496">has</a> (auto &amp;&amp;data) const</td></tr>
<tr class="memdesc:a2a0b01bb14099f6606b164b025611496"><td class="mdescLeft">&#160;</td><td class="mdescRight">an alias for verify <br /></td></tr>
<tr class="separator:a2a0b01bb14099f6606b164b025611496"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad89b16e22d339ec7df37c41def63d20a"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmerkle_1_1TreeBase.html#ad89b16e22d339ec7df37c41def63d20a">height</a> (const size_t leafs_n)</td></tr>
<tr class="memdesc:ad89b16e22d339ec7df37c41def63d20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">a function that allows you to find out the height of any Merkle tree by the number of leaves  <a href="classmerkle_1_1TreeBase.html#ad89b16e22d339ec7df37c41def63d20a">More...</a><br /></td></tr>
<tr class="separator:ad89b16e22d339ec7df37c41def63d20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43e67ff354f9e2ddd9271d0c2178f3e"><td class="memItemLeft" align="right" valign="top"><a id="ad43e67ff354f9e2ddd9271d0c2178f3e"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (const size_t leafs_n)</td></tr>
<tr class="separator:ad43e67ff354f9e2ddd9271d0c2178f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a4fb649690d4181f60e353a0171fafb6b"><td class="memItemLeft" align="right" valign="top"><a id="a4fb649690d4181f60e353a0171fafb6b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmerkle_1_1TreeBase.html#a4fb649690d4181f60e353a0171fafb6b">hash_t</a> = typename std::invoke_result_t&lt; HashFunc, const uint8_t *, size_t &gt;</td></tr>
<tr class="memdesc:a4fb649690d4181f60e353a0171fafb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash function return data type <br /></td></tr>
<tr class="separator:a4fb649690d4181f60e353a0171fafb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:afd5f719ffdf0ed98c2bc0b82345777fc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd5f719ffdf0ed98c2bc0b82345777fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmerkle_1_1TreeBase.html#afd5f719ffdf0ed98c2bc0b82345777fc">hash</a> (T const *const input, const size_t sz) const</td></tr>
<tr class="memdesc:afd5f719ffdf0ed98c2bc0b82345777fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls a hashing function for objects of any type that are continuously located in memory  <a href="classmerkle_1_1TreeBase.html#afd5f719ffdf0ed98c2bc0b82345777fc">More...</a><br /></td></tr>
<tr class="separator:afd5f719ffdf0ed98c2bc0b82345777fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2261c2ac7d994e7009c77317e262cb86"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmerkle_1_1TreeBase.html#a2261c2ac7d994e7009c77317e262cb86">TreeBase</a> (const HashFunc &amp;h)</td></tr>
<tr class="memdesc:a2261c2ac7d994e7009c77317e262cb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor  <a href="classmerkle_1_1TreeBase.html#a2261c2ac7d994e7009c77317e262cb86">More...</a><br /></td></tr>
<tr class="separator:a2261c2ac7d994e7009c77317e262cb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebe74a40b39ee126cec83a837e3d888"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmerkle_1_1TreeBase.html#a9ebe74a40b39ee126cec83a837e3d888">find_leaf</a> (auto &amp;&amp;data) const</td></tr>
<tr class="memdesc:a9ebe74a40b39ee126cec83a837e3d888"><td class="mdescLeft">&#160;</td><td class="mdescRight">a function that finds a leaf of the Merkle tree in the hash container corresponding to the input data  <a href="classmerkle_1_1TreeBase.html#a9ebe74a40b39ee126cec83a837e3d888">More...</a><br /></td></tr>
<tr class="separator:a9ebe74a40b39ee126cec83a837e3d888"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Derived, typename HashFunc&gt;<br />
class merkle::TreeBase&lt; Derived, HashFunc &gt;</h3>

<p>a base template class for building Merkle trees based on CRTP </p>
<p>Class defines the required interface using concepts and provides auxiliary methods for calculating the size, height, leaf search, etc..., through inheritance. All trees inheriting this automatically have some principles for ensuring security, such as double hashing for leaves (protection against Second Preimage Attack) and two generalized algorithms for building a tree (todo status). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>concrete implementation of the Merkle tree </td></tr>
    <tr><td class="paramname">HashFunc</td><td>type of hash function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>uses double leaf hashing to protect against Second Preimage Attacks </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2261c2ac7d994e7009c77317e262cb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2261c2ac7d994e7009c77317e262cb86">&#9670;&nbsp;</a></span>TreeBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename HashFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmerkle_1_1TreeBase.html">merkle::TreeBase</a>&lt; Derived, HashFunc &gt;::<a class="el" href="classmerkle_1_1TreeBase.html">TreeBase</a> </td>
          <td>(</td>
          <td class="paramtype">const HashFunc &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>link to the hash function that will be used to build the tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9ebe74a40b39ee126cec83a837e3d888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ebe74a40b39ee126cec83a837e3d888">&#9670;&nbsp;</a></span>find_leaf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename HashFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classmerkle_1_1TreeBase.html">merkle::TreeBase</a>&lt; Derived, HashFunc &gt;::find_leaf </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a function that finds a leaf of the Merkle tree in the hash container corresponding to the input data </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>any data that can be hashed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position where the leaf hash corresponding to the <code>data</code> arg is located </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if the transmitted data was not used when creating tree, it returns -1 </dd>
<dd>
O(N) complexity where N is equal to the number of leaves in the tree </dd></dl>

</div>
</div>
<a id="ac6b5c1e3375233161d4e19654e6b5c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b5c1e3375233161d4e19654e6b5c4c">&#9670;&nbsp;</a></span>hash() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename HashFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classmerkle_1_1TreeBase.html">merkle::TreeBase</a>&lt; Derived, HashFunc &gt;::hash </td>
          <td>(</td>
          <td class="paramtype">ContiguousContainer auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>ccont</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>hash function wrapper that allows you to call it for any continuous container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ccont</td><td>any continuous container object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of calling the hash function, which calculates the hash from the ccont as a hash from a sequence of bytes </dd></dl>

</div>
</div>
<a id="afd5f719ffdf0ed98c2bc0b82345777fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5f719ffdf0ed98c2bc0b82345777fc">&#9670;&nbsp;</a></span>hash() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename HashFunc &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classmerkle_1_1TreeBase.html">merkle::TreeBase</a>&lt; Derived, HashFunc &gt;::hash </td>
          <td>(</td>
          <td class="paramtype">T const *const&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calls a hashing function for objects of any type that are continuously located in memory </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>pointer to the first object </td></tr>
    <tr><td class="paramname">sz</td><td>number of objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of calling the hash function, which calculates the hash from the data as a hash from a sequence of bytes </dd></dl>

</div>
</div>
<a id="af3dcd283a84eb8bb98021331b0120203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3dcd283a84eb8bb98021331b0120203">&#9670;&nbsp;</a></span>height() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename HashFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmerkle_1_1TreeBase.html">merkle::TreeBase</a>&lt; Derived, HashFunc &gt;::height </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>function that calculates the height of a current Merkle tree </p>
<dl class="section return"><dt>Returns</dt><dd>tree height </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the tree has zero or one (only root) nodes, then the height is zero </dd></dl>

</div>
</div>
<a id="ad89b16e22d339ec7df37c41def63d20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89b16e22d339ec7df37c41def63d20a">&#9670;&nbsp;</a></span>height() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename HashFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr size_t <a class="el" href="classmerkle_1_1TreeBase.html">merkle::TreeBase</a>&lt; Derived, HashFunc &gt;::height </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>leafs_n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a function that allows you to find out the height of any Merkle tree by the number of leaves </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leafs_n</td><td>number of leaves in Merkle tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tree height </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the tree has zero or one (only root) nodes, then the height is zero </dd></dl>

</div>
</div>
<a id="a848a40df2b9f0a4c914b3cea86cd7734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848a40df2b9f0a4c914b3cea86cd7734">&#9670;&nbsp;</a></span>leaf_hash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename HashFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classmerkle_1_1TreeBase.html">merkle::TreeBase</a>&lt; Derived, HashFunc &gt;::leaf_hash </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculates the hash of a tree leaf </p>
<p>uses double leaf hashing to protect against Second Preimage Attacks </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>parameters for calling the hash function (see hash method overloads) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae46ad7d436941315d6b9a831f6b18f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46ad7d436941315d6b9a831f6b18f30">&#9670;&nbsp;</a></span>node_hash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename HashFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classmerkle_1_1TreeBase.html">merkle::TreeBase</a>&lt; Derived, HashFunc &gt;::node_hash </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculates the hash of a tree node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>parameters for calling the hash function (see hash method overloads) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad35655e38316e0d8c9a25ff6e2116c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35655e38316e0d8c9a25ff6e2116c53">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename HashFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classmerkle_1_1TreeBase.html">merkle::TreeBase</a>&lt; Derived, HashFunc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>function that calculates the number of elements (hashes) for a current Merkle tree </p>
<dl class="section return"><dt>Returns</dt><dd>number of hashes in tree </dd></dl>

</div>
</div>
<a id="a48d5593ad35b425b3693af6fd2eac63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d5593ad35b425b3693af6fd2eac63c">&#9670;&nbsp;</a></span>verify()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename HashFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classmerkle_1_1TreeBase.html">merkle::TreeBase</a>&lt; Derived, HashFunc &gt;::verify </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks whether the data block was used when creating the Merkle tree </p>
<p>If the method returns some index that is not equal to the maximum allowed size_t value, therefore, the input data has a corresponding leaf in the tree </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>any data that can be hashed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="merkle_8hpp_source.html">merkle.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
